<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Snake ‚Äî Vanilla JS</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #121833;
      --accent: #66e3a4;
      --accent-2: #7ab7ff;
      --grid: #1b2347;
      --snake: #aef9c8;
      --snake-head: #66e3a4;
      --food: #ff7a90;
      --text: #e7ecff;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 20% -10%, #1b2347 0%, #0b1020 60%) no-repeat,
                  var(--bg);
      color: var(--text);
      display: grid;
      place-items: center;
    }
    .app {
      width: min(96vw, 840px);
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
      padding: 16px;
    }
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.35);
      overflow: hidden;
    }
    .topbar {
      display: flex; align-items: center; justify-content: space-between;
      padding: 12px 16px; gap: 12px;
    }
    .title { font-weight: 700; letter-spacing: 0.4px; }
    .stats { display:flex; gap: 12px; align-items:center; }
    .pill { padding: 6px 10px; border-radius: 999px; background: rgba(122,183,255,0.15); border:1px solid rgba(122,183,255,0.35); font-size: 12px; }
    .btn {
      cursor: pointer; user-select: none;
      padding: 10px 14px; border-radius: 12px; border:1px solid rgba(255,255,255,0.12);
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      color: var(--text);
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
      font-weight: 600; letter-spacing: .3px;
    }
    .btn:hover { transform: translateY(-1px); border-color: rgba(255,255,255,0.25); }
    .btn:active { transform: translateY(0); }
    .btn.primary { background: linear-gradient(180deg, rgba(102,227,164,0.35), rgba(102,227,164,0.12)); border-color: rgba(102,227,164,0.5); }

    .game {
      display: grid; grid-template-columns: 1fr; grid-auto-rows: auto; gap: 0;
    }
    .canvas-wrap { position: relative; padding: 10px; }
    canvas { width: 100%; height: auto; display: block; background: var(--panel); border-radius: 16px; }
    /* On-canvas pixel grid effect */
    .overlay { position: absolute; inset: 10px; pointer-events:none; border-radius: 16px; overflow:hidden; }
    .overlay::after {
      content: ""; position: absolute; inset:0; background-image:
        linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px),
        linear-gradient(0deg, rgba(255,255,255,0.03) 1px, transparent 1px);
      background-size: var(--cell) var(--cell), var(--cell) var(--cell);
      mix-blend-mode: soft-light;
    }

    .help { padding: 12px 16px; display: grid; grid-template-columns: 1fr; gap: 8px; font-size: 14px; opacity: .9; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background: rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.18); padding:2px 6px; border-radius:6px; }

    .touch {
      display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; padding: 12px; width: 100%;
    }
    .dpad { grid-column: 1 / -1; display: grid; grid-template-columns: repeat(3, 64px); grid-template-rows: repeat(3, 64px); place-content: center; gap: 8px; margin: 0 auto; }
    .dpad .d { width: 64px; height: 64px; border-radius: 12px; background: rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.2); display: grid; place-items: center; font-weight: 800; }
    .dpad .d:active { background: rgba(255,255,255,0.16); }

    @media (min-width: 720px) {
      .app { grid-template-columns: 1fr 280px; align-items: start; }
      .game { grid-column: 1; }
      .side { grid-column: 2; position: sticky; top: 16px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="game card">
      <div class="topbar">
        <div class="title">üêç Snake</div>
        <div class="stats">
          <div class="pill" id="scorePill">Score: <span id="score">0</span></div>
          <div class="pill">Speed: <span id="speed">1.0x</span></div>
          <button class="btn primary" id="startBtn">Start / Pause</button>
          <button class="btn" id="resetBtn">Reset</button>
        </div>
      </div>
      <div class="canvas-wrap">
        <canvas id="canvas" width="600" height="600"></canvas>
        <div class="overlay" id="gridOverlay"></div>
      </div>
      <div class="help">
        <div>Controls: <span class="kbd">‚Üë</span><span class="kbd">‚Üì</span><span class="kbd">‚Üê</span><span class="kbd">‚Üí</span> or <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span>. Press <span class="kbd">Space</span> to pause/resume.</div>
        <div>Modes: Toggle wall wrapping with <span class="kbd">X</span>. Toggle turbo with <span class="kbd">T</span>.</div>
      </div>
      <div class="touch" id="touchControls" aria-hidden="true">
        <div class="dpad">
          <div></div>
          <button class="d" data-dir="up">‚Üë</button>
          <div></div>
          <button class="d" data-dir="left">‚Üê</button>
          <div></div>
          <button class="d" data-dir="right">‚Üí</button>
          <div></div>
          <button class="d" data-dir="down">‚Üì</button>
          <div></div>
        </div>
      </div>
    </div>

    <div class="side card">
      <div class="topbar" style="justify-content:flex-start">
        <div class="title">Settings</div>
      </div>
      <div class="help">
        <label>Grid Size
          <input id="gridSize" type="range" min="12" max="40" value="20" />
          <span id="gridVal">20√ó20</span>
        </label>
        <label>Initial Speed (ms / step)
          <input id="speedMs" type="range" min="60" max="300" value="160" />
          <span id="speedVal">160</span>
        </label>
        <label>
          <input id="wrapWalls" type="checkbox" checked /> Wrap through walls
        </label>
        <label>
          <input id="growOnEat" type="checkbox" checked /> Grow on eat
        </label>
        <label>
          <input id="autoAccel" type="checkbox" checked /> Auto speed up
        </label>
      </div>
      <div class="help" style="border-top:1px solid rgba(255,255,255,.08)">
        <div><strong>Tips</strong></div>
        <ul style="margin:8px 0 0 18px; padding:0; line-height:1.7">
          <li>Use <span class="kbd">R</span> to reset quickly.</li>
          <li>Hold <span class="kbd">T</span> for turbo (temporarily faster).</li>
          <li>On mobile, use the on‚Äëscreen D‚Äëpad.</li>
        </ul>
      </div>
    </div>
  </div>

  <script>
    (function(){
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const scoreEl = document.getElementById('score');
      const speedEl = document.getElementById('speed');
      const startBtn = document.getElementById('startBtn');
      const resetBtn = document.getElementById('resetBtn');
      const gridSizeInput = document.getElementById('gridSize');
      const gridVal = document.getElementById('gridVal');
      const speedMsInput = document.getElementById('speedMs');
      const speedVal = document.getElementById('speedVal');
      const wrapWallsInput = document.getElementById('wrapWalls');
      const growOnEatInput = document.getElementById('growOnEat');
      const autoAccelInput = document.getElementById('autoAccel');
      const overlay = document.getElementById('gridOverlay');
      const touch = document.getElementById('touchControls');

      // Game state
      let state;
      let running = false;
      let lastTime = 0;
      let acc = 0;
      let stepMs = +speedMsInput.value; // ms per step
      let turbo = false;

      // Config
      function initState() {
        const N = +gridSizeInput.value;
        const mid = Math.floor(N / 2);
        return {
          N,
          dir: { x: 1, y: 0 },
          nextDir: { x: 1, y: 0 },
          snake: [ {x: mid-1, y: mid}, {x: mid-2, y: mid}, {x: mid-3, y: mid} ],
          food: spawnFood(new Set(), N),
          score: 0,
          alive: true,
        };
      }

      function hash(p){ return p.x + ':' + p.y; }

      function spawnFood(excludeSet, N){
        let x, y;
        do {
          x = Math.floor(Math.random() * N);
          y = Math.floor(Math.random() * N);
        } while (excludeSet.has(x+':'+y));
        return {x,y};
      }

      function draw(){
        const { N, snake, food } = state;
        const cell = Math.floor(Math.min(canvas.width, canvas.height) / N);
        // update overlay grid cell size CSS var
        overlay.style.setProperty('--cell', cell + 'px');

        // clear
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--panel');
        ctx.fillRect(0,0,canvas.width,canvas.height);

        // draw grid light lines (optional aesthetic)
        ctx.strokeStyle = 'rgba(255,255,255,0.05)';
        ctx.lineWidth = 1;
        for (let i=0;i<=N;i++){
          const p = i*cell + 0.5;
          ctx.beginPath(); ctx.moveTo(0, p); ctx.lineTo(N*cell, p); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(p, 0); ctx.lineTo(p, N*cell); ctx.stroke();
        }

        // draw food
        ctx.fillStyle = getCSS('--food');
        roundRect(ctx, food.x*cell+2, food.y*cell+2, cell-4, cell-4, Math.floor(cell/5));
        ctx.fill();

        // draw snake
        for (let i = 0; i < snake.length; i++){
          const seg = snake[i];
          ctx.fillStyle = i === 0 ? getCSS('--snake-head') : getCSS('--snake');
          roundRect(ctx, seg.x*cell+2, seg.y*cell+2, cell-4, cell-4, Math.floor(cell/5));
          ctx.fill();
        }
      }

      function getCSS(varName){
        return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
      }

      function roundRect(ctx, x, y, w, h, r){
        ctx.beginPath();
        ctx.moveTo(x+r,y);
        ctx.arcTo(x+w,y,x+w,y+h,r);
        ctx.arcTo(x+w,y+h,x,y+h,r);
        ctx.arcTo(x,y+h,x,y,r);
        ctx.arcTo(x,y,x+w,y,r);
        ctx.closePath();
      }

      function update(dt){
        const speed = turbo ? Math.max(40, stepMs*0.45) : stepMs;
        acc += dt;
        if (acc < speed) return; // not yet time to step
        acc = 0;

        const { N } = state;
        const snake = state.snake;
        // apply nextDir but prevent reversing into self immediately
        const nd = state.nextDir;
        if (snake.length < 2 || (snake[0].x + nd.x !== snake[1].x || snake[0].y + nd.y !== snake[1].y)){
          state.dir = { ...nd };
        }
        const dir = state.dir;

        // new head
        let nx = snake[0].x + dir.x;
        let ny = snake[0].y + dir.y;

        if (wrapWallsInput.checked){
          nx = (nx + N) % N;
          ny = (ny + N) % N;
        } else {
          if (nx < 0 || ny < 0 || nx >= N || ny >= N){ state.alive = false; return; }
        }

        // self collision
        const snakeSet = new Set(snake.map(hash));
        if (snakeSet.has(nx+':'+ny)) { state.alive = false; return; }

        // move
        snake.unshift({x:nx,y:ny});

        if (nx === state.food.x && ny === state.food.y){
          state.score += 10;
          scoreEl.textContent = state.score;
          // optional auto accelerate
          if (autoAccelInput.checked){
            stepMs = Math.max(60, stepMs - 4);
            speedEl.textContent = (160/stepMs).toFixed(1) + 'x';
          }
          // grow or not
          if (!growOnEatInput.checked){ snake.pop(); }

          // respawn food avoiding snake
          const newSet = new Set(snake.map(hash));
          state.food = spawnFood(newSet, state.N);
        } else {
          // normal move (remove tail)
          snake.pop();
        }
      }

      function loop(ts){
        if (!running) { lastTime = ts; requestAnimationFrame(loop); return; }
        const dt = ts - lastTime; lastTime = ts;
        if (state.alive){
          update(dt);
          draw();
        } else {
          running = false;
          gameOver();
        }
        requestAnimationFrame(loop);
      }

      function gameOver(){
        // overlay text
        const { N } = state;
        const cell = Math.floor(Math.min(canvas.width, canvas.height) / N);
        ctx.fillStyle = 'rgba(0,0,0,0.45)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.font = '700 ' + Math.floor(cell*1.2) + 'px system-ui, sans-serif';
        ctx.fillText('Game Over', canvas.width/2, canvas.height/2);
        ctx.font = '500 ' + Math.floor(cell*0.6) + 'px system-ui, sans-serif';
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        ctx.fillText('Press R to Restart', canvas.width/2, canvas.height/2 + cell*1.2);
      }

      // Input handling
      window.addEventListener('keydown', (e)=>{
        const k = e.key.toLowerCase();
        if (k === ' '){ toggleRun(); e.preventDefault(); return; }
        if (k === 'r'){ reset(); return; }
        if (k === 't'){ turbo = true; return; }
        if (k === 'x'){ wrapWallsInput.checked = !wrapWallsInput.checked; return; }
        if (['arrowup','w'].includes(k)) state.nextDir = {x:0, y:-1};
        else if (['arrowdown','s'].includes(k)) state.nextDir = {x:0, y:1};
        else if (['arrowleft','a'].includes(k)) state.nextDir = {x:-1, y:0};
        else if (['arrowright','d'].includes(k)) state.nextDir = {x:1, y:0};
      });
      window.addEventListener('keyup', (e)=>{ if (e.key.toLowerCase() === 't') turbo = false; });

      // Touch controls
      touch.querySelectorAll('button[data-dir]').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const dir = btn.getAttribute('data-dir');
          if (dir==='up') state.nextDir = {x:0,y:-1};
          if (dir==='down') state.nextDir = {x:0,y:1};
          if (dir==='left') state.nextDir = {x:-1,y:0};
          if (dir==='right') state.nextDir = {x:1,y:0};
        });
      });

      // Buttons
      startBtn.addEventListener('click', toggleRun);
      resetBtn.addEventListener('click', reset);

      gridSizeInput.addEventListener('input', ()=>{ gridVal.textContent = gridSizeInput.value + '√ó' + gridSizeInput.value; softReset(); });
      speedMsInput.addEventListener('input', ()=>{ stepMs = +speedMsInput.value; speedVal.textContent = stepMs; speedEl.textContent = (160/stepMs).toFixed(1)+'x'; });

      // Resize canvas to keep pixel crisp
      function resize(){
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.floor(rect.width * dpr);
        canvas.height = Math.floor(rect.width * dpr); // keep square
        ctx.setTransform(dpr,0,0,dpr,0,0); // scale drawing for crispness
        draw();
        // show touch controls for small screens
        touch.setAttribute('aria-hidden', window.innerWidth > 720 ? 'true' : 'false');
      }
      window.addEventListener('resize', resize);

      function toggleRun(){ running = !running; }

      function reset(){
        state = initState();
        stepMs = +speedMsInput.value;
        scoreEl.textContent = '0';
        speedEl.textContent = (160/stepMs).toFixed(1)+'x';
        running = true; acc = 0; lastTime = performance.now();
        draw();
      }

      function softReset(){
        const wasRunning = running;
        state = initState();
        running = wasRunning; acc = 0; draw();
      }

      // boot
      state = initState();
      resize();
      draw();
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>